=== TODO

- sql sieht komisch aus
- parser + like
- projektion mit id geht nicht weil kein join!
- zu viele sqls!

- Dokka

=== DELETE

delete object
  -> gehe relarionen druch
  -> alle cascade delete
     -> loaded: for all
     -> non loaded: read ids from db

ProbLEM:
 wenn das ganze über mehrere stufen geht ( geladen oder nicht geladen )
===

Neuer Modus:  Orphan removal
vor commit
   Delete object ( rekursive Objekte markiert? ) no
   Aus einer 1:n Relation raus ( mit orphan )
   In neue rein…oder auch nicht

  Es muss Dirty sein!

Commit

   For all dirty
     New
     Modified
     Deleted ( kann rekursiv sein ) ich muss nicht laden!



Ich weiß aber, dass die inverse null oder nonnull ist! Muss geladen sein!


was ist mit create & delete :-)

Zuerst create
Markiere orphans
Dann delete + recursion
Dann modified kann löschen

was ist ein orphan

ich bin modified und habe eine

ich habe eine eingehende relation ( oder relation inverse.removeOrpahn == true... ) && = value = null!

product ->> part

=== LATER

- admin service CRUD
- kopieren nach service :-)
- angular :-) mit builder simple

=== NOW

- cascade delete?
- orphan removal

=== DONE

- state = BitSet
- owner
- cascadeDelete & removeOrphans
- admin service finalisieren
- TODOs in MVR
- join children geht, father nicht :-)
- like
- doku
- graphql benchmark?
- test data?
- default value
- applikation
- maven submodule
- date support in graphql ( scalar )
- session überlegen
- status
- version counter & optimistic locking
- boolean expression
- updatePerson -> [Person]n
- restliche filter
- fix create relation
- mehrwertige relation
- create + realtion?
- mutation relations?
- join für einwertige...
- bulk update
- delete-person
- mutation: create/update
- postman test
- restliche prädikate
- Spring einbinden
- überlegen syntax select?
- argument
- resolver?????
- TEST
- Schema selber machen
- Transaktionsklammer
- Spring
- @Components
- beispiel java klasse
- hello world